// ##2. 데이터 타입들 
// Rust 에서 사용되는 모든 값들은 어떠한 타입을 갖는다. 

// 그러니 어떤 형태의 데이터인지 명시해 Rust에게 알려주어 이를 통해 데이터를 어떻게 다룰지 알 수 있게 해야한다. 
// 이번 장에서는, 우리는 언어에 포함되어 있는 여러 타입들을 사용해보고자 한다. 

// 타입은 크게 스칼라와 컴파운드, 둘로 나눌 수 있다.
// 이번 장에서는 전체에 걸쳐서 주지해야 할 점은 Rust는 타입이 고정된 언어라는 점이다. 이것이 의미하는 바는 
// 모든 변수의 타입이 컴파일 시에 반드시 정해져 있어야 한다는 것이다. 보통 컴파일러는 우리가 값을 사용하는 지에 따라서 
// 타입을 추측할 수 있다. 2장에서 String을 parse를 사용해 숫자로 변환 했던 경우 처럼 타입의 선택 폭이 넒은 경우에 
// 반드시 타입의 명시를 첨가해주어야 한다. 
// fn main() {
//     // println!("데이터 타입");

//     // 이곳에 타입 명시를 첨가하지 않을 경우, Rust에서는 에러를 발생시킨다.
//     // 이와 같은 에러는 우리에게 사용하고자 하는 타입이 무엇인지에 대한 정보를 요구하는 것 
//     let guess: u32 = "42".parse().expect("Not a number");

// }


// ##2.1. 스칼라 타입들 
// 스칼라는 하나의 값으로 표현되는 타입이다. Rust는 정수형, 부동소수점 숫자, boolean, 그리고 문자, 총 네가지 스칼라 타입을 보유하고 있다.

// ##2.1-1. 정수형 
// 정수형은 소수점이 없는 숫자로, 이번 장에서는 앞부분의 u32 타입인 정수형을 사용했다.
// 해당 타입의 선언은 부호가 없는 32비트 변수임을 나타낸다(부호가 있는 타입은 u 대신에 i로 시작한다.)
// 표 3-1은 Rust에서 사용되는 정수형들을 보여준다. 부호, 미부호로 나뉜 다른 열의 타입을 사용해 정수 값의 타입을 선언할 수 있다.

// Table 3-1 - Rust에서의 정수 타입

/** 
 *  Length  Signed  UnSigned
 *  8-bit   i8       u8
 *  16-biy  i16      u16
 *  32-bit  i32      u32
 *  64-bit  i64      u64
 *  arch    isize    usize
 * 
**/

// 위에 각각의 타입은 부호 혹은 미부호 이며 명시된 크기를 갖는다. 부호 혹은 미부호의 의미는, 숫자가 양수 혹은 음수를 다룰 수 있는가 
// 혹은 없는가를 나타낸다. 다르게 말하면, 숫자가 부호를 가져야 할 경우(부호) 혹은 오직 양수만을 가질 것이기에 부호 없이도 표현할 수 있는가(미부호)를 나타낸다.

// 종이에 숫자를 기재하는 것과 동일하다. 부호가 함께 다뤄야 하는 경우에 숫자는 더하기 혹은 빼기 기호와 함께 표시하는데 
// 숫자가 양수라 가정해도 문제 없는 상황에는 부호 없이 표시하게 된다. 

// 부호된 숫자는 2의 보수 형태를 사용해 저장된다
// 각 부호의 변수는  -(2n - 1) 부터 2n -1 - 1 까지의 값을 포괄한다. 이곳에서 n은 사용되는 타입의 비트 수이다. 
// 즉 i8은 -(2/7)에서 2/7 - 1 까지의 값, 즉 -128 에서 127 사이의 값을 저장할 수 있다. 미부호 타입은 0에서 2n - 1 까지의 값을 저장할 수 있다. 
// 즉 u8 타입은 0에서 2/8 - 1 다시 말해서, 0에서 255까지의 값을 저장할 수 있다. 

// 추가로 isize와 usize 타입은 당신의 프로그램이 동작하는 컴퓨터 환경이 64-bits 인지 아닌지에 따라 결정되는데 
// 64-bit 아키텍쳐 환경이이라면 64bit를, 32-bit 아키텍처 환경이면 32bit를 갖게된다. 

// 당신은 아래 테이블에서 보여주는 형태들 처럼 정수형 리터럴을 사용할 수 있다. byte 리터럴을 제외하고는 
// 모든 정수형 리터럴은 57u8과 같은 타입 접미사와 1_000과 같이 시각적인 구분을 위한 _의 사용을 허용한다.

// Table 3-2 - Rust의 정수형 리터럴들 

/**
    Number literals    Example 
    Decimal             98_222
    Hex                 0xff
    Octal               0o77
    Binary              0b1111_0000
    Byte(u8 only)       b'A'
 */

 // 그렇다면 어떤 타입의 정수를 사용해야 할까? 
 // 확실하게 정해진 경우가 아니라면 Rust의 기본 값인 i32가 일반적으로 좋은 선택이다. 

 // 이는 일반적으로 가장 빠르기 떄문인데, 심지어 64-bit 시스템이서도 
 // isize나 usize는 주로 일부 콜렉션 타입의 색인에 사용된다.


 // ##2.2 - 부동 소수점 타입 
 // Rust에서는 소수점을 갖는 숫자인 부동 소수점 숫자를 위한 두 가지 기본 타입도 있다. Rust의 부동소수점 타입은 
 // f32와 f64로 32bit와 64bit 크기를 갖는다 .기본 타입은 f64인데 그 이유로는 최신의 CPU 상에서 f64가 f32와 
 // 대략 비슷한 속도를 내면서 더 정밀한 표현이 가능하기 떄문이다.

 // ##2.3 - 부동 소수점 타입 예제 
//  fn main() {
//      // 부동 소수점 숫자는 IEEE-754 표준에 따라 표현되는데, f32 타입은 1배수의 정밀도인 부동 소수점 이고,
//      // f64는 2배수의 정밀도인 부동 소수점이다.
//     //  let x = 2.0 // f64

//     //  let y: f32 = 3.0 // f32

//     // 수학적 연산들 
//     // Rust가 지원하는 일반적 기본 수학적 연산으로는 모든 숫자 타입에 적용된다.
//     // 더하기(+), 곱하기(*), 나누기(/) 등등

//     // 다음 코드의 예제로 let 문 내에서 사용할 수 있는 방법
    
//     // addtion 
//     let sum = 5 + 10;

//     // subraction 
//     let diffrences = 95.5 - 4.3;

//     // multiplication
//     let product = 4 * 30;

//     // division
//     let quotient = 56.7 / 32.2;

//     // remainder 
//     let remainder = 43 % 5;
    
//         // 위 문장에서 각 표현식으로 수학 연산자를 사용해 산출된 값을 변수로 bound 한다. 부록 B에 Rust에서 제공하는 
//         // 모든 연산자 목록이 들어있다.
      
      
// }


  // #2.3 - Boolean 타입 
  // 대부분 다른 언어들 처럼, boolean 타입은 Rust에서 둘 중 하나의 값만 가질 수 있다. true와 false 
  // boolean 타입은 러스트에서 bool로 명시된다.
//   fn main() {
//       // boolean 값을 사용하는 주된 방법으로 if문과 같은 조건문에서 조건으로 사용하는 것이다.
//       // 우리는 if문이 Rust에서 동작하는 방식을 "제어 흐름"에서 다룰 것이다.
//       let t = true;

//       let f:bool = false;
//   }


// // #2.4 - 문자 타입 
// // 지금까지 숫자 타입만을 살펴보았는데, Rust는 문자 또한 지원한다. Rust의 char은 이 언어의 가장 근본적인 
// // 알파벳 타입으로, 다음의 코드는 이를 사용하는 한 가지 방법이다. string이 큰따옴표를 쓰는 것에 반하여
// // char 타입은 작은 따움표를 쓰는 점을 주목!!
// fn main() {
//     // Rust의 char 타입은 Unicode Scalr를 표현하는 값이고 이는 ASCll 보다 많은 표현을 가능케 한다. 억양 표시가 있는 문자 
//     // 한국어/중국어/일본어 표의 문자, 이모티콘, 넓이가 0인 공백문자 모두가 Rust에서는 char 타입으로 사용할 수 있다.

//     // Unicode Scalar 값의 범위는 U+0000 에서 U+D7FF 그리고 U+E000에서 U+10FFFF를 포괄한다.
//     // 그럼에도 불구하고 "문자"는 Unicode를 위한 개념이 아니기에 당신의 인간적 직관에 따른 "문자"와 Rust의 char이 동일하지 않을 수 있다.
//     let c = 'z';
//     let z = 'Z';
//     let heart_eyed_cat = '😻';

//     println!("{}",heart_eyed_cat)
// }


// #2.5 - 복합 타입들 
// 복합 타입들은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있다. Rust는 두 개의 기본 타입들을 갖고 있다. 튜플과 배열 

// #2.5-1 값들을 집합시켜 튜플화 하기 
// 튜플은 다양한 타입의 몇 개의 숫자를 집합시켜 하나의 복합 타입으로 만드는 일반적인 방법이다.

// 우리는 괄호 안에 콤마로 구분되는 값들의 목록을 작성해 튜플을 만든다. 튜플에 포함되는 각 값의 타입이 동일할 필요없이 서로 달라도 된다.
// 다음의 예제에 우리는 선택 사항인 타입 명시를 추가해보겠다.

// fn main() {
    
//     // 튜플은 단일 요소를 위한 복합계로 고려되었기에 변수 tup 에는 튜플 전체가 bind 된다. 개별적인 값을 튜플의 밖으로 빼네오기 위해서
//     // 패턴 매칭을 사용해 튜플의 값을 구조해체 시키면 된다.
//     // let tup: (i32, f64, u8) = (500, 6.4, 1);

//     // 구조해체 
//     // 해당 프로그램은 처음에 튜플을 만들고 변수 tup에 bind를 시킨다. 
//     // 이후 패턴과 let을 통해서 tupㅇ을 세게의 분리된 변수 x,y 그리고 z에 이동시킨다. 
//     // 이것을 구조해체라고 부르는 이유로는 하나의 튜플을 세 부분으로 나누기 떄문이다.

//     // 최종적으로 프로그램은 y의 값을 출력할 것이고 이는 6.4이다.
//     // 패턴 매칭을 통한 구조해체에 추가로, 우리는 마침표(.) 뒤에 우리가 접근하길 원하는 값의 색인을 넣는 것을 통해 
//     // 튜플의 요소에 직접적으로 접근할 수 있다.
//     // let (x,y,z) = tup;


//     // 튜플 접근 에제 
//     // 튜플 x를 만들고, 이의 각 요소들을 그들의 색인을 통해 접근해 새 변수를 만든다.
//     // 대부분 언어가 그렇듯 튜플의 첫 번째 색인은 0이다.
//     let x: (i32, f64, u8) = (500, 6.4, 1);

//     let five_hundred = x.0;

//     let six_point_four = x.1;

//     let one = x.2;

//     println!("The value of y is: {}", five_hundred);
//     println!("The value of y is: {}", six_point_four);
//     println!("The value of y is: {}", one);

    
// }


// #2.6 - 배열 
// 여러 값들의 집합체를 만드는 다른 방법은 배열이다. 튜플과는 다르게, 배열의 모든 요소는 모두 같은 타입이어야 한다. 
// 한번 선언되면, 이들의 크기는 커지거나 작아지지 않는다. 
// Rust에서 대괄호 안에 값들을 콤마로 구분해 나열해 배열을 만든다.

// fn main() {

//     // 배열이 유용할 떄는 당신의 데이터를 heap 보다 stack에 할당하는 것을 원하거나 당신이 항상 고정된 숫자의 요소를 갖는다고 확신하고 싶을때이다.
//     // 이들은 백터 타입처럼 가변적이지 않다. 백터 타입은 유사 집합체로 표준 라이브러리에서 제공되며 확장 혹은 축소가 가능하다.
//     // 배열이나 백터 중에 무엇을 선택해야 할지 확실치 않은 상황이라면 백터를 사용하도록 한다.

//     let a = [1,2,3,4,5];
//     // 백터가 아닌 배열을 선택할 경우 예로, 프로그램이 올해의 달 이름을 알고자하는 경우이다.
//     // 프로그램에 달을 추가하거나 삭제할 경우는 거의 없을 것이므로, 고정적으로 12개의 아이템을 가질테닌 배열을 사용하면 된다.

//     let months = ["January", "February", "March", "April", "May", "June", "July",
//                   "Aguest", "September", "October", "November", "December"];

// }

// #2.6-1. 유효하지 않은 배열 요소 접근 
// 만약우리가 배열의 끝을 넘어선 요소에 접근하려 한다면 어떻게 될까 ?
// 컴파일시에는 어러가 발생하지 않지만, 프로그램 결과는 실행 중 에러가 발생하고 
// 성공적으로 종료되지 못했다고 반환한다.

// 색인을 사용해 요소에 접근하려고 한다면 Rust는 지정한 색인이 배열 길이보다 작은지를 확인한다. 
// 색인이 길이보다 길면 Rust는 지정한 색인이 배열 길이보다 작은지를 확인한다. 색인이 길이보다 길면 
// Rust는 프로그램이 오류와 함꼐 종료 될 때 Rust가 사용하는 용어인 *패닉(panic)* 한다.

// 이것은 Rust의 안전 원칙이 동작하는 첫번째 예로, 많은 저수준 언어에서 이러한 타입의 검사는 수행되지 않으며 
// 잘못된 색인을 제공한다면 유효하지 않은 메모리에 엑세스 할 수 있다. Rust는 메모리 접근을 허용하고 계속 진행하는 대신 
// 즉시 종료하여 이러한 종류의 오류들로부터 사용자를 보호한다. 
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}