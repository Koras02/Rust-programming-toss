// #1. 변수와 가변성 

// fn main() {

//     // 해당 예제는 컴파일러가 만든 프로그램에서 당신을 도와 에러를 찾아주는 방법에 대해 보여주고 있다.
//     // 컴파일러 에러가 힘빠지게 만들 수 있지만, 단지 당신의 프로그램이 아직 안전하게 수행되기에는 미흡하다는 뜻이지 
//     // 소양이 부족함은 아니다.

//     // 에러가 나타나는 것은 불변성 변수에 재할당이고, 원인은 우리가 불변성 변수 x에 두번쨰로 값을 할당했기 때문이다. 
//     // 우리가 이전에 불변성으로 선언한 것의 값을 변경하고자 하는 시도를 하면 컴파일 타임의 에러를 얻게 되고 이로 인해서 
//     // 버그가 발생할 수 있기 때문에 중요하다. 

//     // 만약 우리 코드의 일부는 값이 변경되지 않는다는 것을 가정하는데 다른 코드는 이와 다르게 값을 변경한다면, 전자에 해당하는 코드는 
//     // 우리가 의도한 대로 수행되지 않을 수 있다.
//     // 특히 후자에 해당되는 코드가 항상 그렇지 않고 가끔 값을 변경하는 경우 나중에 버그의 원인을 추적하기가 매우어렵다.
//     // Rust에서는 컴파일러가 변경되지 않은 값에 대해 보증을 해주고, 실제로 이는 바꾸지 않는다.

//     // 이것이 의미하는 바는 당신이 코드를 작성하거나 분석할 시 에 변수의 값이 어떻게 변경되는지 추적할 필요가 없기 때문에 코드를 더 합리적으로 
//     // 만들어 준다 .
    

//     // 하지만 가변성은 매우 유용하게 사용할 수 있는데, 변수는 기본적으로 불변성이지만 우리는 변수명의 접두어로 mut라는 키워드를 추가하는 것을 통해서 
//     // 가변성 변수를 선언할 수 있다. 이 변수의 값이 변경을 허용하는 것에 추가로 향후 코드를 보는 사람에게 코드의 다른 부분에서 해당 변수의 값을 변경할 것이라는 의도를 
//     // 주지시킨다. 
//     let x = 5;
//     println!("The value of x is: {}", x);

//     x = 6;
//     println!("The value of x is: {}", x);
// }


// // #2. mut를 사용할때 
// fn main() {
//     // mut를 사용해 x에 bind된 값을 5에서 6으로 변경시킬 수 있다. 불변성 변수만을 사용하는 것보다 
//     // 가변성 변수를 사용해 보다 쉽게 구현할 수 있을 경우 가변성 변수를 만들어 사용할 수 있다.

//     // 이런 의사 결정에 있어서 버그를 예방하는 것 외에도 고려해야할 요소들이 있다. 예를 들어서, 대규모 데이터 구조체를 
//     // 다룰 경우에 가변한 인스턴스를 사용하는 것이 새로 인스턴스를 할당하고 반환하는 것보다 빠를 수 있다. 

//     // 데이터 규모가 작을 수록 새 인스턴스를 생성하고 함수적 프로그래밍 스타일로 작성하는 것이 더 합리적이고 
//     // 그렇기에 약간의 성능 하락을 통해서 가독성을 확보할 수 있다면 더 가치있는 선택일 것이다.

//     let mut x = 5;
//     println!("The value of x is: {}", x);
//     x = 6;
//     println!("The value of x is: {}", x);
// }

// ##3. 변수와 상수 간의 차이점 
// 변수의 값을 변경할 수 없다는 사항이 아마 당신에게는 다른 언어가 가진 프로그래밍 개념을 떠오르게 할 것이다.
// 상수 불변성 변수와 마찬가지로 상수 또한 이름으로 bound된 이후 값의 변경이 허용되지 않지만 
// 상수와 변수는 서로 조금 다른 점이 있다.

// ##3-1. 상수 
// 첫번째로 상수에 대해서는 mut를 사용하는 것을 허용하지 않는다!!
// 상수는 기본 설정이 불변성인 것이 아닌 불변성 그 자체 이다.

// ## 상수 예 


// 우리가 상수를 사용하고자 할때 let 키워드 대신 const라는 키워드를 사용해야하고 
// 값의 유형을 선언해야 하는데, 우리가 사용할 수 있는 유형들과 유형의 선언을 챕터 "Data Types:"에서 다루게 될 것이다. 

// 상수는 전체 영역을 포함해 어떤 영역에서도 선언될 수 있다. 이는 코드의 많은 부분에서 사용될 필요가 있는
// 값을 다루는데 유용하다.

// 마지막 차이점은 상수는 오직 상수 표현식만 설정될 수 있으며, 함수 호출의 결과갑싱나 그 외 실행 시간에 결정되는 값이 
// 설정될 수 없다는 점이다.

// fn main() {
//   // 상수는 자신이 선언되 있는 영역 내에서 프로그램이 실행되는 시간 동안 항상 유효하기에 
//   // 당신의 어플리케이션 도메인 전체에 걸쳐서 프로그램의 다양한 곳에서 사용되는 값을 상수로 하면 굉장히 유용하다.
//   // 사용자가 한 게임에서 흭득할 수 있는 최대 포인트, 빛의 속도 같은 값 등등..

//   // 당신의 프로그램 전체에 걸쳐서 하드코드 해야하는 값을 이름지어서 상수로 사용하면 향후 코드를 유지보수 하게 될 사람에게
//   // 그 의미를 전달할 수 있으므로 유용하다. 또한 향후 해당 값을 변경해야 할 경우 상수로 선언된 값 한 곳만 변경하면 되므로 도움이 될 것이다.
//     // const MAX_POINTS: u32 = 100_000;


//     // 

// }


// ##4. Shadowing 
// 앞서 우리가 2장에서 추측 예제를 통해 보았듯이, 이전에 선언한 변수와 같은 이름의 새 변수를 선언해줄 수 있고
// 새 변수는 이전 변수를 shadows하게 된다. Rustaceans들은 이를 첫 변수가 두 번째에 의해서 
// shadowed 되었다고 표현하게 된다. 해당 변수명은 두 번째 변수의 값을 갖게 된다는 뜻 
// let 키워드를 사용해 다음처럼 반복해 같은 변수명으로 변수를 shadow할 수 있다.

fn main() {
    // 이 예제는 처음 x에 5값을 bind하고, 이후 반복된 let x = 구문으로 x를 shadow하고 원본 값에 1을 더해 
    // x의 값은 6이된다. 
    // 이와 같은 사용은 변수를 mut로 선언하는 것과는 차이가 발생하게 된다. 그 이유는 let 키워드를 사용하지 않고 변수에 
    // 새로 값을 대입하려고 하면 컴파일-시 에러를 얻게 되기 때문. 우리가 몇 번 값을 변경시킬 수 있으나 그 이후 변수는 불변성을 가지게 된다.
    let x = 5;
    
    let x = x + 1; 

    // 세 번째 let문으로 x를 또 shadow하고 이전 값에 2를 곱해 x의 최종값은 12가 되는 것이다.
    let x = x * 2;

    println!("The Value of x is: {}", x);

    // 또다른 mut와 Shadowing의 차이는 let 키워드를 다시 사용해 효과적으로 새 변수를 선언하고, 값의 유형을 
    // 변경할 수 있으면서도 동일한 이름을 사용할 수 있다는 점이다. 예를 들어서, 공백 문자들을 입력 받아 얼마나 
    // 많은 공백 문자가 있는지 보여주고자  때, 실제로는 저장하고자 하는 것은 공백의 개수들일터


    // 이와 같은 구조가 허용되는 이유는 첫 spaces 변수가 문자열 유형이고 두 번째 spaces 변수는 첫번째 것과 동일한 이름을 가진 
    // 새롭게 정의된 숫자 유형의 변수이기 떄문이다. Shadowing은 space_str이나 space_num과 같이 대체된 이름을 사용하는 대신에 
    // 간단히 spaces이름을 사용할 수 있게 해준다. 그러나 우리가 mut를 사용하고자 한다면 
    let spaces = "   ";
    let spaces = spaces.len();

    // 변수의 유형을 변경할 수 없다는 컴파일 에러가 발생한다.
    // let mut spaces = "  " ;
    // spaces = spaces.len();
}